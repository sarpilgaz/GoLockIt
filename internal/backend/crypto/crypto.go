package crypto

import (
	"crypto/rand"
	"errors"
	"fmt"

	"golang.org/x/crypto/argon2"
	"golang.org/x/crypto/chacha20poly1305"
	"golang.org/x/crypto/sha3"
)

const (
	//advised time param value to argon
	ARGON_TIME = 1

	//advised memory size to argon
	ARGON_MEM = 64 * 1024

	//num of threads to use for argon keygen
	ARGON_THREADS = 4

	//length of the securely generated key used by chacha20, generated by argon
	KEY_LEN = 32

	//length of a min salt in bytes
	MIN_SALT_LEN = 16
)

var (
	Err0LengthPassword = errors.New("0 length password given")
	ErrInvalidSalt     = errors.New("given salt is too short, need at least 16 bytes")
	Err0LengthKey      = errors.New("shake: input key is empty")
)

func Genkey(password []byte, salt []byte) ([]byte, error) {
	//use argon2id to generate a secure 32 byte key from the password given

	//this non-zero should be enforced by the cli, but why not also here
	if len(password) == 0 {
		return []byte{}, Err0LengthPassword
	}

	if len(salt) < MIN_SALT_LEN {
		return nil, ErrInvalidSalt
	}

	key := argon2.IDKey(password, salt, ARGON_TIME, ARGON_MEM, ARGON_THREADS, KEY_LEN)

	return key, nil
}

func HashPassword(key []byte) ([]byte, error) {
	//use sha3 to hash a given securely generated key
	//pretty redundant, since we can store argon2id output in db,
	if len(key) == 0 {
		return []byte{}, Err0LengthKey
	}

	digest := make([]byte, 32)

	shake := sha3.NewShake256()
	shake.Write(key)
	shake.Read(digest)

	return digest, nil
}

func EncryptPassword(password []byte, key []byte) ([]byte, error) {
	//use chacha20 to create a nonce, then encrypt the password with the securely created key
	if len(password) == 0 {
		fmt.Println("password of length 0 passed to hash")
		return []byte{}, Err0LengthPassword
	}

	aead, err := chacha20poly1305.NewX(key)
	if err != nil {
		panic("cipher creation failed")
	}

	nonce := make([]byte, aead.NonceSize(), aead.NonceSize()+len(password)+aead.Overhead())
	if _, err := rand.Read(nonce); err != nil {
		panic("nonce reading failed")
	}

	return aead.Seal(nonce, nonce, password, nil), nil
}

func DecryptPassword(encryptedPassword []byte, key []byte) ([]byte, error) {
	//use chacha20 to decrpyt a given password using the securely created key
	aead, err := chacha20poly1305.NewX(key)
	if err != nil {
		panic("cipher creation failed")
	}

	nsize := aead.NonceSize()

	if len(encryptedPassword) < nsize {
		panic("decrypt: ciphertext too short")
	}

	nonce, ciphertext := encryptedPassword[:nsize], encryptedPassword[nsize:]

	plainPassword, err := aead.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return []byte{}, err
	}

	return plainPassword, nil
}
