package crypto

import (
	"crypto/rand"
	"errors"
	"fmt"

	"golang.org/x/crypto/argon2"
	"golang.org/x/crypto/chacha20poly1305"
	"golang.org/x/crypto/sha3"
)

const (
	//advised time param value to argon
	argonTime = 1

	//advised memory size to argon
	argonMem = 64 * 1024

	//num of threads to use for argon keygen
	argonThreads = 4

	//length of the securely generated key used by chacha20, generated by argon
	keyLen = 32

	//length of a min salt in bytes
	MinSaltLen = 16
)

func Genkey(password []byte, salt []byte) ([]byte, error) {
	//use argon2id to generate a secure 32 byte key from the password given
	var err error

	//this non-zero should be enforced by the cli, but why not also here
	if len(password) == 0 {
		fmt.Println("empty password given to keygen")
		return []byte{}, err
	}

	if len(salt) < MinSaltLen {
		return nil, fmt.Errorf("derive key: salt length %d too short, need ≥%d bytes", len(salt), MinSaltLen)
	}

	key := argon2.IDKey(password, salt, argonTime, argonMem, argonThreads, keyLen)

	return key, nil
}

func HashPassword(key []byte) ([]byte, error) {
	//use sha3 to hash a given securely generated key
	//pretty redundant, since we can store argon2id output in db,
	if len(key) == 0 {
		fmt.Println("password of length 0 passed to hash")
		return []byte{}, errors.New("shake: input key is empty")
	}

	digest := make([]byte, 32)

	shake := sha3.NewShake256()
	shake.Write(key)
	shake.Read(digest)

	return digest, nil
}

func EncryptPassword(password []byte, key []byte) ([]byte, error) {
	//use chacha20 to create a nonce, then encrypt the password with the securely created key
	if len(password) == 0 {
		fmt.Println("password of length 0 passed to hash")
		return []byte{}, errors.New("encrypt: password is empty")
	}

	aead, err := chacha20poly1305.NewX(key)
	if err != nil {
		fmt.Println("cipher creation failed")
		return []byte{}, err
	}

	nonce := make([]byte, aead.NonceSize(), aead.NonceSize()+len(password)+aead.Overhead())
	if _, err := rand.Read(nonce); err != nil {
		fmt.Println("nonce reading failed")
	}

	return aead.Seal(nonce, nonce, password, nil), nil
}

func DecryptPassword(encryptedPassword []byte, key []byte) ([]byte, error) {
	//use chacha20 to decrpyt a given password using the securely created key
	aead, err := chacha20poly1305.NewX(key)
	if err != nil {
		fmt.Println("cipher creation failed")
		return []byte{}, err
	}

	nsize := aead.NonceSize()

	if len(encryptedPassword) < nsize {
		return nil, fmt.Errorf("decrypt: ciphertext too short: got %d bytes, need ≥%d", len(encryptedPassword), nsize)
	}

	nonce, ciphertext := encryptedPassword[:nsize], encryptedPassword[nsize:]

	plainPassword, err := aead.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		fmt.Println("ciphertext has been tampered with")
		return []byte{}, nil
	}

	return plainPassword, nil
}
